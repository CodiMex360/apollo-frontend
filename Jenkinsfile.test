pipeline {
    agent any

    options {
        disableConcurrentBuilds()
        timeout(time: 30, unit: 'MINUTES')
    }

    environment {
        DOCKER_REPO = "mikeangeloo/apollo-frontend"  // Repositorio de Docker
        // Extraemos la rama sin el prefijo "origin/"
        BRANCH_NAME = sh(script: "echo ${env.GIT_BRANCH} | sed 's|^origin/||'", returnStdout: true).trim()
        GITHUB_REPO = 'CodiMex360/apollo-frontend'
        GITHUB_TOKEN = credentials('GITHUB_TOKEN')
        COMMIT_SHA = sh(script: "git rev-parse HEAD", returnStdout: true).trim()

        PACKAGE_VERSION = ''   // Versi√≥n extra√≠da de package.json
        IMAGE_TAG = ''         // Etiqueta que se usar√° para la imagen Docker
        DOCKER_IMAGE = ''      // Referencia de la imagen Docker construida

        // Bandera para distinguir PR vs Merge; se inicializa en false (merge)
        IS_PR = "false"
        TAG_ID = ''
    }

    stages {
        stage('Detectar PR con API') {
            steps {
                script {
                    def prData = getPRData()
                    if (prData) {
                        TAG_ID = prData.number
                        env.TARGET_BRANCH = prData.targetBranch
                        env.IS_PR = "true"
                        echo "‚úÖ Detectado PR: #${prData.number} con target branch ${prData.targetBranch}"
                    } else {
                        echo "No se detect√≥ PR, asumiendo merge a la target branch."
                        env.IS_PR = "false"
                    }
                }
            }
        }

         stage('Detectar Merge') {
            steps {
                script {
                    def commitMessage = sh(script: "git log -1 --pretty=%B", returnStdout: true).trim()
                    echo "Mensaje del √∫ltimo commit: ${commitMessage}"

                    if (commitMessage.contains("Merge pull request")) {
                        def prNumber = commitMessage.find(/#(\d+)/) { match, num -> return num }
                        echo "üöÄ Se detect√≥ un merge del PR #${prNumber}"
                        TAG_ID = prNumber
                    } else {
                        echo "‚ö†Ô∏è No se detect√≥ merge directo."
                    }
                }
            }
        }

        stage('Confirmar PR fusionado con GitHub API') {
            steps {
                script {
                    def mergedPR = sh(script: """
                        curl -s -H "Authorization: token ${env.GITHUB_TOKEN}" \\
                        "https://api.github.com/repos/${env.GITHUB_REPO}/pulls?state=closed" | jq -r '.[] | select(.merge_commit_sha == "${env.GIT_COMMIT}") | .number'
                    """, returnStdout: true).trim()

                    if (mergedPR) {
                        echo "‚úÖ Confirmado: PR #${mergedPR} fue fusionado"
                        TAG_ID = mergedPR
                    } else {
                        echo "‚ö†Ô∏è No se encontr√≥ el PR fusionado en la API."
                    }
                }
            }
        }

        stage('Start') {
            steps {
                script {
                    updateGitHubCommitStatus('pending')
                    echo "Pipeline iniciado para el commit ${COMMIT_SHA}"
                }
            }
        }

        stage('Validate TAG_ID') {
            steps {
              script {
                if (!TAG_ID) {
                  echo "üö´ Saltando ejecuci√≥n del pipeline, no se encontro un TAG_ID."
                  currentBuild.result = 'ABORTED'
                  return // Esto detiene la ejecuci√≥n
                }
              }
            }
        }

        stage('Checkout') {
            steps {
                checkout scm
                script {
                    echo "üì• Se han bajado los cambios de la rama ${BRANCH_NAME}"
                }
            }
        }

        stage('Obtener versi√≥n y formar IMAGE_TAG') {
            steps {
                script {
                    PACKAGE_VERSION = sh(script: "jq -r .version package.json", returnStdout: true).trim()
                    echo "üìå Versi√≥n extra√≠da: ${PACKAGE_VERSION}"
                    IMAGE_TAG = "${DOCKER_REPO}:${PACKAGE_VERSION}-${TAG_ID}"
                }
            }
        }

        stage('Construir imagen Docker') {
            agent { label 'docker-agent' }
            when {
                expression { return env.IS_PR == "true" }
            }
            steps {
                script {
                    echo "üöÄ Construyendo imagen Docker..."
                    DOCKER_IMAGE = docker.build("${IMAGE_TAG}")
                }
            }
        }

        stage('Publicar imagen en Docker Hub') {
            agent { label 'docker-agent' }
            when {
                expression { return env.IS_PR == "true" }
            }
            steps {
                script {
                    if (DOCKER_IMAGE) {
                        echo "üì§ Publicando imagen en Docker Hub..."
                        withDockerRegistry([credentialsId: 'DOCKER_HUB_CRED']) {
                            DOCKER_IMAGE.push()
                        }
                    } else {
                        error "‚ùå La imagen Docker no se construy√≥ correctamente."
                    }
                }
            }
        }

        stage('Desplegar en EKS') {
            agent { label 'k8s-agent' }
            when {
                expression { return env.IS_PR == "true" }
            }
            steps {
                script {
                    echo "üöÄ Desplegando entorno ef√≠mero en EKS para PR..."
                    def namespace = "pr-${TAG_ID}"
                    def imageTag = IMAGE_TAG
                    def backendURL = "host.docker.internal:8081"
                    // Se asume que el directorio clonado incluye la carpeta k8s en la ra√≠z
                    dir('apollo-frontend/k8s') {
                        sh 'ls -la'
                        sh "chmod +x scripts/deploy.sh"
                        // Ejecutar el script sin comillas extra para que se interprete correctamente
                        sh "scripts/deploy.sh ${namespace} ${imageTag} ${backendURL}"
                    }
                }
            }
        }

        stage('Eliminar Entorno Ef√≠mero') {
            when {
                expression { return env.IS_PR == "false" }
            }
            steps {
                script {
                    echo "üî¥ Eliminando entorno ef√≠mero y borrando imagen (merge a target branch)..."
                    def namespace = "pr-${TAG_ID}"
                    def imageTag = IMAGE_TAG
                    def deleteImage = "True"
                    dir('apollo-frontend/k8s') {
                        sh "chmod +x scripts/delete.sh"
                        sh "scripts/delete.sh ${namespace} ${imageTag} ${deleteImage}"
                    }
                }
            }
        }
    }

    post {
        success {
            script {
                echo "Pipeline exitoso. Actualizando estado en GitHub a success."
                updateGitHubCommitStatus('success')
            }
        }
        failure {
            script {
                echo "Pipeline fallido. Actualizando estado en GitHub a failure."
                updateGitHubCommitStatus('failure')
            }
        }
        aborted {
            script {
                updateGitHubCommitStatus('error')
            }
        }
        always {
            script {
                echo "Finalizando el pipeline."
            }
        }
    }
}

// Funci√≥n para actualizar el estado del commit/PR en GitHub
def updateGitHubCommitStatus(String status) {
    echo "Actualizando el estado del commit en GitHub a: ${status}"
    withCredentials([string(credentialsId: 'GITHUB_TOKEN', variable: 'GITHUB_TOKEN')]) {
        sh """
            curl -X POST -H "Authorization: token ${GITHUB_TOKEN}" \
            -d '{"state": "${status}", "target_url": "${JENKINS_URL}job/${JOB_NAME}/${BUILD_NUMBER}", "description": "Build ${status}", "context": "CI/CD Pipeline"}' \
            https://api.github.com/repos/${GITHUB_REPO}/statuses/${GIT_COMMIT}
        """
    }
}

// Funci√≥n para obtener datos del PR mediante la API de GitHub
def getPRData() {
    def response = sh(script: """
        curl -s -H "Authorization: token ${env.GITHUB_TOKEN}" \\
        "https://api.github.com/repos/${env.GITHUB_REPO}/pulls?state=open" | jq -r '.[] | select(.head.sha == "${env.GIT_COMMIT}") | {number, base: .base.ref}'
    """, returnStdout: true).trim()
    def prNumber = sh(script: "echo '${response}' | jq -r '.number'", returnStdout: true).trim()
    def targetBranch = sh(script: "echo '${response}' | jq -r '.base'", returnStdout: true).trim()
    if (prNumber && targetBranch) {
        return [ number: prNumber, targetBranch: targetBranch ]
    } else {
        return null
    }
}
