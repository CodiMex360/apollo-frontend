pipeline {
    agent any

    options {
        disableConcurrentBuilds()
        timeout(time: 30, unit: 'MINUTES') // Cancela si tarda m√°s de 30 min
    }

    environment {
        DOCKER_REPO = "mikeangeloo/apollo-frontend"  // Cambiar con tu repositorio de Docker
        BRANCH_NAME = sh(script: "echo ${env.GIT_BRANCH} | sed 's|^origin/||'", returnStdout: true).trim()
        BUILD_VERSION = "${env.BUILD_NUMBER}"    // N√∫mero √∫nico de build de Jenkins

        GITHUB_REPO = 'CodiMex360/apollo-frontend' // Reemplaza con tu repositorio
        GITHUB_TOKEN = credentials('GITHUB_TOKEN')  // Aqu√≠ usas el token configurado como credencial
        COMMIT_SHA = sh(script: "git rev-parse HEAD", returnStdout: true).trim()  // SHA del commit actual

        PACKAGE_VERSION = ''                     // Almacenar√° la versi√≥n del package.json
        IMAGE_TAG = ''                           // Etiqueta para la imagen Docker
        DOCKER_IMAGE = ''                        // Definiendo para guardar la referencia de la imagen de docker

        PR_NUMBER = ''                           // Obtiene el n√∫mero del PR
    }

    stages {

        stage('Validar si es un PR') {
          steps {
            script {
              // Asignaci√≥n segura del n√∫mero de PR
              def PR_NUMBER = env.CHANGE_ID ?: ''

              echo "CHANGE_ID: ${env.CHANGE_ID} // GIT_BRANCH: ${env.GIT_BRANCH}"

              echo "üîç Listando variables de entorno con printenv:"
              sh 'printenv'

              echo "GITHUB_PR_URL: ${GITHUB_PR_URL}"

              // Validaci√≥n: si no es un PR, detener ejecuci√≥n
              if (!PR_NUMBER.trim()) {
                  error "üö® Este pipeline solo se ejecuta en Pull Requests. Deteniendo ejecuci√≥n."
              } else {
                  echo "‚úÖ Ejecutando pipeline para PR #${PR_NUMBER}"
              }
            }
          }
        }

        stage('Start') {
          steps {
            script {
              // Actualizamos el estado inicial a github
              updateGitHubCommitStatus('pending')

              echo "Pipeline iniciado para el commit ${COMMIT_SHA}"
            }
          }
        }

        stage('Checkout') {
            steps {
                checkout scm // Esta es la acci√≥n para clonar el repositorio
                script {
                    echo "üì• Se han bajado los cambios de la rama ${BRANCH_NAME}"
                }
            }
        }

        stage('Obtener versi√≥n del package.json y formar IMAGE_TAG') {
            steps {
                script {
                    // Obtener la versi√≥n desde el archivo package.json
                    PACKAGE_VERSION = sh(script: "jq -r .version package.json", returnStdout: true).trim()
                    echo "üìå Versi√≥n extra√≠da: ${PACKAGE_VERSION}"

                    IMAGE_TAG = "${DOCKER_REPO}:${PACKAGE_VERSION}-${BUILD_VERSION}-${BRANCH_NAME}"
                }
            }
        }

        stage('Contruir imagen Docker') {
          agent { label 'docker-agent' }
          steps {
            script {
              // Construir la imagen Docker
              echo "üöÄ Construyendo imagen Docker..."
              DOCKER_IMAGE = docker.build("${IMAGE_TAG}")
            }
          }
        }

        //Descomentar en AWS
        // stage('Ejecutar pruebas unitarias') {
        //     agent { label 'docker-agent' }
        //     steps {
        //         script {
        //           if (DOCKER_IMAGE) {
        //             // Ejecutar las pruebas unitarias con Jest para Angular
        //             echo "‚ö° Ejecutando pruebas unitarias ..."
        //             DOCKER_IMAGE.inside {
        //                 // Posicionarse en el directorio correcto (aunque /app es el directorio de trabajo)
        //                 sh 'pwd'
        //                 sh 'ls -la'
        //                 sh 'npm run test:ci'  // Ejecutar pruebas unitarias

        //                 // Obtener la cobertura global desde el JSON de cobertura
        //                 def coverageJson = readJSON(file: 'coverage/coverage-summary.json')
        //                 def coverage = coverageJson.total.statements.pct  // Extrae el porcentaje de cobertura total

        //                 echo "üìä Cobertura de c√≥digo: ${coverage}%"

        //                 if (coverage.toFloat() < 80) {
        //                     error "üö® Cobertura de pruebas menor al 80%. No se puede continuar con el pipeline."
        //                 }
        //             }
        //           } else {
        //             error "‚ùå La imagen Docker no se construy√≥ correctamente. El pipeline se detiene."
        //           }
        //         }
        //     }
        // }

        // stage('An√°lisis con SonarQube') {
        //     steps {
        //         script {
        //             // An√°lisis del c√≥digo con SonarQube
        //             echo "üîç Ejecutando an√°lisis con SonarQube..."
        //             sh 'sonar-scanner'
        //         }
        //     }
        // }

        stage('Publicar imagen en Docker Hub') {
            agent { label 'docker-agent' }
            steps {
                script {
                    if (DOCKER_IMAGE) {
                       // Autenticaci√≥n con Docker Hub y publicaci√≥n de las im√°genes
                        echo "üì§ Publicando imagen en Docker Hub..."
                        withDockerRegistry([credentialsId: 'DOCKER_HUB_CRED']) {
                            echo "üì§ Publicando imagen en Docker Hub..."
                             DOCKER_IMAGE.push()
                        }
                    } else {
                       error "‚ùå La imagen Docker no se construy√≥ correctamente. El pipeline se detiene."
                    }
                }
            }
        }

        stage('Desplegar en EKS') {
            steps {
                script {
                    // Desplegar en EKS para validar cambios (ef√≠mero)
                    echo "üöÄ Desplegando en EKS..."
                    sh "./scripts/deploy.sh pr-${BUILD_VERSION} ${IMAGE_TAG} host.docker.internal:8080"
                }
            }
        }
    }

   post {
        success {
            script {
                // Actualizamos el estado del PR a 'success'
                echo 'Pipeline exitoso. Actualizando estado en GitHub.'
                updateGitHubCommitStatus('success')
            }
        }
        failure {
            script {
                // Actualizamos el estado del PR a 'failure'
                echo 'Pipeline fallido. Actualizando estado en GitHub.'
                updateGitHubCommitStatus('failure')
            }
        }
         aborted {
            script {
                updateGitHubCommitStatus('error')  // Actualiza el estado como cancelado
            }
        }
        always {
            script {
                // Este paso siempre se ejecutar√° al final, independientemente del resultado
                echo 'Finalizando el pipeline.'
            }
        }
        cleanup {
          when {
            expression {
              // Verificar si el PR ha sido cerrado o fusionado
              return env.CHANGE_ID != null && (env.PULLREQUEST_STATE == 'merged' || env.PULLREQUEST_STATE == 'closed')
            }
          }
          steps {
            script {
                sh "./scripts/delete.sh pr-${BUILD_VERSION} ${IMAGE_TAG} true"
            }
          }
        }
   }
}

// Funci√≥n personalizada para actualizar el estado del commit en GitHub
def updateGitHubCommitStatus(String status) {
    // Funci√≥n para actualizar el estado del PR en GitHub
    echo "Actualizando el estado del PR en GitHub a: ${status}"
    withCredentials([string(credentialsId: 'GITHUB_TOKEN', variable: 'GITHUB_TOKEN')]) {
        sh """
            curl -X POST -H "Authorization: token ${GITHUB_TOKEN}" \
            -d '{"state": "${status}", "target_url": "${JENKINS_URL}job/${JOB_NAME}/${BUILD_NUMBER}", "description": "Build ${status}", "context": "CI/CD Pipeline"}' \
            https://api.github.com/repos/${GITHUB_REPO}/statuses/${GIT_COMMIT}
        """
    }
}
